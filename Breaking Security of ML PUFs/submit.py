# -*- coding: utf-8 -*-
"""Untitled26.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YOcOwfbXqvcMxp-kdgQxJVbJ65G2HMqU
"""

import numpy as np
import sklearn
from scipy.linalg import khatri_rao
from sklearn.svm import LinearSVC
from sklearn.metrics import accuracy_score

# You are allowed to import any submodules of sklearn that learn linear models e.g. sklearn.svm etc
# You are not allowed to use other libraries such as keras, tensorflow etc
# You are not allowed to use any scipy routine other than khatri_rao

# SUBMIT YOUR CODE AS A SINGLE PYTHON (.PY) FILE INSIDE A ZIP ARCHIVE
# THE NAME OF THE PYTHON FILE MUST BE submit.py

# DO NOT CHANGE THE NAME OF THE METHODS my_fit, my_map, my_decode etc BELOW
# THESE WILL BE INVOKED BY THE EVALUATION SCRIPT. CHANGING THESE NAMES WILL CAUSE EVALUATION FAILURE

# You may define any new functions, variables, classes here
# For example, functions to calculate next coordinate or step length

################################
# Non Editable Region Starting #
################################
def my_fit(X_train, y_train):
################################
#  Non Editable Region Ending  #
################################

    # Use this method to train your models using training CRPs
    # X_train has 8 columns containing the challenge bits
    # y_train contains the values for responses

    # THE RETURNED MODEL SHOULD BE ONE VECTOR AND ONE BIAS TERM
    # If you do not wish to use a bias term, set it to 0
    C = 0.0065
    feat_train = my_map(X_train)
    model = LinearSVC(dual=False, max_iter=10000, C=C)
    model.fit(feat_train, y_train)
    w = model.coef_.flatten()
    b = model.intercept_[0]
    return w, b


################################
# Non Editable Region Starting #
################################
def my_map(X):
################################
#  Non Editable Region Ending  #
################################

    # Use this method to create features.
    # It is likely that my_fit will internally call my_map to create features for train points
    n_samples, _ = X.shape
    expanded_dim = 702
    features = np.zeros((n_samples, expanded_dim))

    for i in range(n_samples):
        c = X[i]
        t = 1 - 2 * c

        # Linear terms (8 terms)
        linear_terms = c

        # Product terms (28 terms): Directly concatenate all terms in the summation
        product_terms = []
        for a in range(1, 8):
            slice_t = t[:a]
            reversed_prod = np.cumprod(slice_t[::-1])[::-1]
            terms = c[a] * reversed_prod
            product_terms.extend(terms.tolist())

        # Combine linear and product terms (8 + 28 = 36)
        original_phi = np.concatenate([linear_terms, product_terms])

        # Quadratic terms (upper triangle of outer product, 666 terms)
        outer = np.outer(original_phi, original_phi)
        tri_indices = np.triu_indices_from(outer)
        quadratic_terms = outer[tri_indices]

        # Final feature vector (36 + 666 = 702)
        features[i] = np.concatenate([original_phi, quadratic_terms])

    return features


################################
# Non Editable Region Starting #
################################
def my_decode(w):
################################
#  Non Editable Region Ending  #
################################

    # Use this method to invert a PUF linear model to get back delays
    # w is a single 65-dim vector (last dimension being the bias term)
    # The output should be four 64-dimensional vectors
    N = 64  # P_0 to P_63

    # Unknowns: P_0,...,P_63, q_63 (total 65 unknowns)
    # Let x = [P_0, ..., P_63, q_63]
    A = np.zeros((65, 65))
    b = np.zeros(65)

    for i in range(65):
        if i == 0:
            A[i, 0] = 0.5
            b[i] = w[i]
        elif i < 64:
            A[i, i] = 0.5
            A[i, i - 1] = 0.5
            if i == 63:
                A[i, 64] = -0.5
            b[i] = w[i]
        else:  # i == 64
            A[i, 63] = 0.5
            A[i, 64] = -0.5
            b[i] = w[i]
    A[63, 64] = 0

    # Solve the system (handle singularity)
    if np.linalg.det(A) == 0:
        solution = np.linalg.pinv(A) @ b
    else:
        solution = np.linalg.solve(A, b)

    P = solution[:64]
    q63 = solution[64]

    # Find largest negative value among P and q63
    all_values = np.append(P, q63)
    negative_values = all_values[all_values < 0]
    if negative_values.size > 0:
        largest_negative = np.min(negative_values)
    else:
        largest_negative = 0

    # Shift all values so smallest negative becomes zero
    shift_value = 0 - largest_negative
    P_new = P + shift_value
    q63_new = q63 + shift_value

    # Build the 256-length array
    arr = np.zeros(256)
    arr[0:64] = P_new
    arr[64:127] = shift_value
    arr[127] = q63_new
    arr[128:] = 0

    # Split array into four equal parts
    p, q, r, s = np.array_split(arr, 4)
    return p, q, r, s